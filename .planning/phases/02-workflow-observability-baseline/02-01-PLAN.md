---
phase: 02-workflow-observability-baseline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - projects/web_api/web_api/main.py
  - projects/web_api/web_api/models/responses.py
  - projects/web_api/web_api/reporting_routes.py
  - projects/web_api/tests/test_workflow_observability.py
  - docs/usage_guide.md
files-modified: [projects/web_api/web_api/main.py, projects/web_api/web_api/models/responses.py, projects/web_api/web_api/reporting_routes.py, projects/web_api/tests/test_workflow_observability.py, docs/usage_guide.md]
autonomous: true
objective: "Implement object-level lifecycle correlation APIs and status signal propagation so operators can trace ingestion, workflow execution, and publication outcomes by object_id."
requirements:
  - OBS-01
  - OBS-02
user_setup: []
must_haves:
  truths:
    - "Operators can retrieve a single object lifecycle timeline keyed by object_id from ingestion through enrichment outcomes"
    - "Workflow status payloads expose stable correlation fields for dashboard and runbook consumption"
  artifacts:
    - path: "projects/web_api/web_api/models/responses.py"
      provides: "typed lifecycle and observability response contracts"
      min_lines: 40
    - path: "projects/web_api/web_api/main.py"
      provides: "object lifecycle and correlation-focused workflow endpoints"
    - path: "projects/web_api/tests/test_workflow_observability.py"
      provides: "regression coverage for lifecycle and status payload behavior"
  key_links:
    - from: "projects/web_api/web_api/models/responses.py"
      to: "projects/web_api/web_api/main.py"
      via: "response_model enforcement for lifecycle/status routes"
    - from: "projects/web_api/web_api/main.py"
      to: "docs/usage_guide.md"
      via: "documented operator workflow for object-level correlation"
---

<objective>
Implement object-level lifecycle correlation APIs and status signal propagation so operators can trace ingestion, workflow execution, and publication outcomes by object_id.

Purpose: satisfy the Phase 2 correlation foundation before dashboard and alert policy work.
Output: lifecycle endpoint(s), normalized status payloads, and API regression tests.
</objective>

<execution_context>
@/Users/maleick/.codex/get-shit-done/workflows/execute-plan.md
@/Users/maleick/.codex/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/STATE.md
@.planning/phases/02-workflow-observability-baseline/02-RESEARCH.md
@projects/web_api/web_api/main.py
@projects/web_api/web_api/models/responses.py
@projects/web_api/web_api/queue_monitor.py
@libs/common/common/workflows/tracking_service.py
@infra/postgres/01-schema.sql
</context>

<tasks>

## Task 1
<task type="auto">
  <name>Task 1: Add lifecycle-focused observability response contracts</name>
  <files>projects/web_api/web_api/models/responses.py, projects/web_api/web_api/reporting_routes.py</files>
  <action>Introduce response models for object lifecycle and correlation summaries (ingestion timestamps, workflow ids/statuses, enrichment outcome counts, and publication indicators). Keep existing response models backward compatible for current dashboard consumers.</action>
  <verify>cd projects/web_api && uv run pytest tests/test_workflow_observability.py -q</verify>
  <done>Typed lifecycle contract exists and can represent object_id-centered traceability without breaking existing workflow status models</done>
</task>

## Task 2
<task type="auto">
  <name>Task 2: Implement object lifecycle and status propagation endpoints</name>
  <files>projects/web_api/web_api/main.py, projects/web_api/web_api/models/responses.py</files>
  <action>Add API route(s) that return lifecycle correlation for a single object_id and normalize workflow status payload correlation fields (`workflow_id`, `object_id`, timestamps, failure context). Reuse existing PostgreSQL sources (`files_enriched`, `workflows`, `enrichments`, `findings`, `transforms`) rather than adding new infrastructure in this plan.</action>
  <verify>cd projects/web_api && uv run pytest tests/test_workflow_observability.py -q</verify>
  <done>Operators can query one object_id and receive a deterministic ingestion-to-publication lifecycle view with correlation-friendly status metadata</done>
</task>

## Task 3
<task type="auto">
  <name>Task 3: Add regression tests and operator usage guidance</name>
  <files>projects/web_api/tests/test_workflow_observability.py, docs/usage_guide.md</files>
  <action>Create tests covering happy path, missing object_id, and failed workflow edge cases for lifecycle/status routes. Update usage docs with an object_id correlation workflow example so operators can consistently triage processing issues.</action>
  <verify>cd projects/web_api && uv run pytest tests/test_workflow_observability.py -q</verify>
  <done>Lifecycle observability behavior is test-protected and documented for routine operator use</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd projects/web_api && uv run pytest tests/test_workflow_observability.py -q` passes
- [ ] New lifecycle route(s) return consistent correlation fields for running/completed/failed workflows
- [ ] Existing `/workflows/status` and `/workflows/failed` payloads remain backward compatible for dashboard consumers
</verification>

<success_criteria>

- Object lifecycle can be traced by `object_id` from ingestion to publication outcomes
- Workflow status APIs expose stable correlation fields suitable for dashboard and alert consumers
- Regression tests cover lifecycle and failure-path behavior for the new contracts

</success_criteria>

<output>
After completion, create `.planning/phases/02-workflow-observability-baseline/02-01-SUMMARY.md`
</output>
